#! /usr/bin/env python3

import argparse
import json
import os
import pwd
import shutil
import subprocess
from pathlib import Path
from typing import Optional

VALID_USERS = ["kris", "joram"]
VALID_OPERATIONS = ["create", "delete", "show"]
VALID_PROJECT_TYPES = ["static_site", "wsgi_site", "discord_bot"]
PROJECT_DIR = Path("/etc/projects")

args: argparse.Namespace


def chown_tree(start: Path, username: str, groupname: Optional[str] = None, topdown=True):
    """ change the ownership of the file tree starting at `start` to
        the UNIX user `username` and the UNIX group `groupname`.
        When `topdown` is set (the default) change happens from top to bottom,
        otherwise the other way around.
    """
    if groupname is None:
        groupname = username

    for root, dirs, files in os.walk(start, topdown=topdown):
        for the_dir in dirs:
            dname = Path(root) / the_dir
            shutil.chown(dname, username, groupname)

        for the_file in files:
            fname = Path(root) / the_file
            shutil.chown(fname, username, groupname)

    shutil.chown(start, username, groupname)


def project_type(the_type: str) -> str:
    """ ArgumentParser validator for project types. """
    if the_type in VALID_PROJECT_TYPES:
        return the_type

    raise ValueError(f"invalid project type {the_type}, valid types are {VALID_PROJECT_TYPES}")


def operation(the_op: str) -> str:
    """ ArgumentParser validator for the positional parameter operation.
        Valid operations are in VALID_OPERATIONS.
        We raise a ValueError for anything else.
    """
    if the_op in VALID_OPERATIONS:
        return the_op

    raise ValueError(f"invalid operation {the_op}, valid operatios are {VALID_OPERATIONS}")


def run(cmd: str) -> int:
    """ Run a command, and report
    """
    print(f"*** RUN: {cmd}")
    result = subprocess.run(cmd, capture_output=True, shell=True, timeout=30)

    code = result.returncode
    stdout = result.stdout.decode('utf-8')
    stderr = result.stderr.decode('utf-8')

    if code != 0:
        print(f"*** ERROR: exit code={result.returncode}")

    if stdout:
        print(f"*** STDOUT: {stdout}")
    if stderr:
        print(f"*** STDERR: {stderr}")

    return code


def check_project_exists(project: str) -> bool:
    p = PROJECT_DIR / project
    return p.exists() and p.is_file()


def check_username_exists(username: str) -> bool:
    try:
        pwd.getpwnam(username)
        return True
    except KeyError:
        return False


def check_hostname_valid(hostname: str) -> bool:
    if hostname.endswith(".snackbag.net"):
        return True

    return False


def check_github_valid(github: str) -> bool:
    if github.startswith("git@github.com:"):
        return True

    return False


def get_update_cmd():
    return "update_cmd"  # TODO


def get_restart_cmd():
    return "restart_cmd"  # TODO


def get_log_cmd():
    return "log_cmd"  # TODO


def get_opts():
    """ Parse the program options using ArgumentParser.
        The collected arguments are left in a global variable args.
    """
    global args

    parser = argparse.ArgumentParser()
    parser.add_argument("operation", type=operation, help="show, create or delete")
    parser.add_argument("project", help="a valid project name, or 'show projects'")

    parser.add_argument("--type", type=project_type, help="one of static_site, wsgi_site or discord_bot")
    parser.add_argument("--hostname", help="hostname ending in .snackbag.net (in create)")
    parser.add_argument("--github", help="git@github.com:...")
    parser.add_argument("--deploykey", help="pathname of a deploykey (private key part)")
    parser.add_argument("--username", help="a unix username to be created (in create)")
    parser.add_argument("--projectdir", help="a subdirectory name in that users home (in create)")

    args = parser.parse_args()


def validate_opts():
    global args

    if check_project_exists(args.project):
        raise ValueError(f"project {args.project} already exists")

    if not args.username:
        args.username = args.project
    if check_username_exists(args.username):
        raise ValueError(f"username {args.username} already exists")

    if not args.hostname:
        args.hostname = f"{args.project}.snackbag.net"
    if not check_hostname_valid(args.hostname):
        raise ValueError(f"hostname {args.hostname} does not end in '.snackbag.net'")

    if not args.github:
        raise ValueError(f"github is empty; specify --github <somegithub>")
    if not check_github_valid(args.github):
        raise ValueError(f"github {args.github} is not a valid github url 'git@github.com:...")

    if not args.projectdir:
        args.projectdir = args.username

    args.update_cmd = get_update_cmd()
    args.restart_cmd = get_restart_cmd()
    args.log_cmd = get_log_cmd()

    return


def do_create_user() -> int:
    # user must be created
    comment = f"Project {args.project} owner"
    useradd_cmd = f'/usr/sbin/useradd -m -c "{comment}" {args.username}'
    code = run(useradd_cmd)

    u = pwd.getpwnam(args.username)
    args.userid = u.pw_uid

    return code


def do_create_ssh_key():
    u = pwd.getpwnam(args.username)
    homedir = Path(u.pw_dir)

    if not args.deploykey:
        sshdir = homedir / ".ssh"
        sshdir.mkdir(0o700, parents=True, exist_ok=True)
        args.deploykey = f"{sshdir}/id_deploykey"

        ssh_config_filename = sshdir / "config"
        ssh_config_content = f"""
Host github
    HostName github.com
    User git
    IdentityFile {args.deploykey}
    IdentitiesOnly yes
"""
        with open(ssh_config_filename, "wt") as ssh_config:
            ssh_config.write(ssh_config_content)

    sshkeygen_cmd = f'ssh-keygen -t rsa -b 4096 -N "" -f {args.deploykey}'
    code = run(sshkeygen_cmd)

    pubkeyfilename = f"{args.deploykey}.pub"
    with open(pubkeyfilename, "rt") as f:
        args.pubkey = f.read().strip()

    chown_tree(homedir, args.username, args.username)


def do_create_projectfile():
    projectfile = PROJECT_DIR / args.project
    projectdesc = {
        "type": args.type,
        "project": args.project,
        "hostname": args.hostname,
        "github": args.github,
        "deploykey": args.deploykey,
        "pubkey": args.pubkey,
        "projectdir": args.projectdir,
        "username": args.username,
        "userid": args.userid,
        "update_cmd": args.update_cmd,
        "restart_cmd": args.restart_cmd,
        "log_cmd": args.log_cmd,
    }
    projectfile_content = json.dumps(projectdesc, indent=2, sort_keys=True)

    with open(projectfile, "wt") as projectfile:
        projectfile.write(projectfile_content)


def do_git_clone():
    u = pwd.getpwnam(args.username)
    home = Path(u.pw_dir)
    repo = home / args.projectdir

    git_clone_cmd = f"git clone {args.github} {repo}"
    code = run(git_clone_cmd)

    chown_tree(repo, args.username, args.username)


def do_create():
    do_create_user()
    do_create_ssh_key()
    do_create_projectfile()
    do_git_clone()


def main():
    get_opts()
    validate_opts()

    # operation is one of the things in VALID_OPERATIONS
    if args.operation == "create":
        do_create()
    elif args.operation == "delete":
        print(f"delete: {args}")
    elif args.operation == "show":
        print(f"show: {args}")
    else:
        raise ValueError(f"This can never happen: {args.operation=}")


if __name__ == "__main__":
    main()
