#! /usr/bin/env python3

import argparse
import getpass
import json
import os
import pwd
import re
import shutil
import subprocess
import sys
from pathlib import Path
from typing import Optional

VALID_USERS = ["kris", "joram"]
VALID_OPERATIONS = ["create", "delete", "show"]
VALID_PROJECT_TYPES = ["static_site", "wsgi_site", "discord_bot"]
PROJECT_DIR = Path("/etc/projects")

args: argparse.Namespace


def chown_tree(start: Path, username: str, groupname: str, topdown=True):
    """ change the ownership of the file tree starting at `start` to
        the UNIX user `username` and the UNIX group `groupname`.
        When `topdown` is set (the default) change happens from top to bottom,
        otherwise the other way around.
    """
    for root, dirs, files in os.walk(start, topdown=topdown):
        for the_dir in dirs:
            dname = Path(root) / the_dir
            shutil.chown(dname, username, groupname)

        for the_file in files:
            fname = Path(root) / the_file
            shutil.chown(fname, username, groupname)

    shutil.chown(start, username, groupname)


def valid_caller() -> str:
    """ Deployments can be done by one of the users listed in VALID USERS.
        We raise a ValueError if we are being run by somebody else.
    """
    user = getpass.getuser()
    if user in VALID_USERS:
        return user

    raise ValueError(f"invalid user {user}, valid users are: {VALID_USERS}")


def project_type(the_type: str) -> str:
    """ ArgumentParser validator for project types. """
    if the_type in VALID_PROJECT_TYPES:
        return the_type

    raise ValueError(f"invalid project type {the_type}, valid types are {VALID_PROJECT_TYPES}")


def operation(the_op: str) -> str:
    """ ArgumentParser validator for the positional parameter operation.
        Valid operations are in VALID_OPERATIONS.
        We raise a ValueError for anything else.
    """
    if the_op in VALID_OPERATIONS:
        return the_op

    raise ValueError(f"invalid operation {the_op}, valid operatios are {VALID_OPERATIONS}")


def show_run_result(result: subprocess.CompletedProcess):
    """ Print a `subcommand.run()` result structure.
    """
    code = result.returncode
    stdout = result.stdout.decode('utf-8')
    stderr = result.stderr.decode('utf-8')

    if code == 0:
        print("*** SUCCESS:")
    else:
        print(f"*** ERROR: exit code={result.returncode}")

    if stdout:
        print(stdout)
    if stderr:
        print(stderr)


def create_user(username: str, homedir: Optional[str] = None, comment: Optional[str] = None):
    """ Create a new user `username`.

        The User will have the homedir `/home/<username>` unless a different `homedir` is specified.

        The User will have the comment `Managed WGSI Application <username>` unless a different `comment` is specified.

        If `exist_ok == True`, it is okay for the user to exist, but a ValueError will be raised, if `homedir`
        or `comment` do not match.
    """
    username_regex = r"[a-z_][a-z0-9_]{1,10}"
    m = re.fullmatch(username_regex, username)
    if m is None:
        raise ValueError(f"username '{username}' does not match '{username_regex}'")

    if homedir is None:
        homedir = f"/home/{username}"

    if comment is None:
        comment = f"Managed WSGI Application {username}"

    # user must be created
    useradd_cmd = f"/usr/sbin/useradd -d {homedir} -c {comment} {username}"
    useradd_result = subprocess.run(useradd_cmd, shell=True, capture_output=True, timeout=30)
    show_run_result(useradd_result)

    return


def _create_dotsshdir(homedir: Path):
    """ Create a subdirectory `.ssh` in the users home directory.
        The ownership for this directory is not set properly.
    """
    sshdir = homedir / ".ssh"
    sshdir.mkdir(0o700, parents=True, exist_ok=True)

    return


def _create_sshkey(homedir: Path) -> str:
    """ Create a `.ssh` subdirectory in the users home. Then generate a passwordless
        RSA 4096-bit ssh keypair in there.
        The ownership for the directory and the key are not set properly.

        Returns the pubkey part of the generated keypair.
    """
    _create_dotsshdir(homedir)

    sshkeygen_cmd = "ssh-keygen -t rsa -b 4096 -N "" -f {homedir}/.ssh/id_rsa"
    sshkeygen_result = subprocess.run(sshkeygen_cmd, shell=True, capture_output=True, timeout=30)
    show_run_result(sshkeygen_result)

    pubkeyfilename = f"{homedir}/.ssh/id_rsa.pub"
    with open(pubkeyfilename, "rt") as f:
        pubkey = f.read()

    return pubkey


def create_deploy_description(project: str,
                              hostname: Optional[str] = None,
                              unixuser: Optional[str] = None,
                              projectdir: Optional[str] = None,
                              checkout_cmd: Optional[str] = None,
                              restart_cmd: Optional[str] = None,
                              log_cmd: Optional[str] = None,
                              overwrite: bool = False):
    """ Create a deployment description for a project in `/etc/projects`.
        Will not overwrite an existing project unless `overwrite=True`.

        Optional parameters can be passed, or will be inferred, if left at `None`.

        Default `hostname` is `<project>.snackbag.net.
        Default `unixuser` is `<project>`.
        Default `projectdir` is `$HOME/<project>`.
        Default `checkout_cmd` is `git pull --rebase`.
        Default `restart_cmd` is `sudo apache_restart`.
        Default `log_cmd` is `tail -F`.
    """
    if hostname is None:
        hostname = f"{project}.snackbag.net"

    if unixuser is None:
        unixuser = project

    if projectdir is None:
        u = pwd.getpwnam(unixuser)
        h = u.pw_dir
        projectdir = f"{h}/{project}"

    if checkout_cmd is None:
        checkout_cmd = CHECKOUT_CMD

    if restart_cmd is None:
        restart_cmd = RESTART_CMD

    if log_cmd is None:
        log_cmd = LOG_CMD

    # check the hostname
    if not hostname.endswith("snackbag.net"):
        raise ValueError(f"invalid hostname {hostname}, must end in 'snackbag.net'")

    # to json
    deployment = {
        "hostname": hostname,
        "unixuser": unixuser,
        "projectdir": projectdir,
        "checkout_cmd": checkout_cmd,
        "restart_cmd": restart_cmd,
        "log_cmd": log_cmd,
    }
    deployment_json = json.dumps(deployment, indent=2, sort_keys=True) + "\n"

    # write it
    p = PROJECT_DIR / project
    if p.is_file() and not overwrite:
        print(f"Project {project} already exists.", file=sys.stderr)
        raise FileExistsError(f"can't create: project {project} exists.")

    with p.open("wt") as f:
        f.write(deployment_json)

    return


def check_username_exists(username: str) -> bool:
    try:
        pwd.getpwnam(username)
        return True
    except KeyError:
        return False


def check_hostname_valid(hostname: str) -> bool:
    if hostname.endswith(".snackbag.net"):
        return True

    return False


def check_github_valid(github: str) -> bool:
    if github.startswith("git@github.com:"):
        return True

    return False


def get_update_cmd():
    return "update_cmd"  # TODO


def get_restart_cmd():
    return "restart_cmd"  # TODO


def get_log_cmd():
    return "log_cmd"  # TODO


def get_opts():
    """ Parse the program options using ArgumentParser.
        The collected arguments are left in a global variable args.
    """
    global args

    parser = argparse.ArgumentParser()
    parser.add_argument("operation", type=operation, help="code or deploy, logs, show, create, delete")
    parser.add_argument("project", help="a valid project name")

    parser.add_argument("--type", type=project_type, help="one of static_site, wsgi_site or discord_bot")
    parser.add_argument("--hostname", help="hostname ending in .snackbag.net (in create)")
    parser.add_argument("--github", help="git@github.com:...")
    parser.add_argument("--deploykey", help="pathname of a deploykey (private key part)")
    parser.add_argument("--username", help="a unix username to be created (in create)")
    parser.add_argument("--projectdir", help="a subdirectory name in that users home (in create)")

    args = parser.parse_args()


def validate_opts():
    global args

    if check_username_exists(args.username):
        raise ValueError(f"username {args.username} already exists")

    user = pwd.getpwnam(args.username)
    args.userid = user.pw_uid

    if not check_hostname_valid(args.hostname):
        raise ValueError(f"hostname {args.hostname} does not end in '.snackbag.net'")

    if not check_github_valid(args.github):
        raise ValueError(f"github {args.github} is not a valid github url 'git@github.com:...")

    args.update_cmd = get_update_cmd()
    args.restart_cnd = get_restart_cmd()
    args.log_cmd = get_log_cmd()

    return


def main():
    # Check valid user, and grab the call options
    user = valid_caller()
    get_opts()
    validate_opts()

    # operation is one of the things in VALID_OPERATIONS
    if args.operation == "create":
        print(f"create {args}")
    elif args.operation == "delete":
        print(f"delete: {args}")
    elif args.operation == "show":
        print(f"show: {args}")
    else:
        raise ValueError(f"This can never happen: {args.operation=}")


if __name__ == "__main__":
    main()
