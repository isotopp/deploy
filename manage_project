#! /usr/bin/env python3.11

import argparse
import json
import os
import pwd
import shutil
import subprocess
from pathlib import Path
from typing import Optional

VALID_USERS = ["kris", "joram"]
VALID_OPERATIONS = ["create", "delete", "show"]
VALID_PROJECT_TYPES = ["static_site", "wsgi_site", "discord_bot"]
PROJECT_DIR = Path("/etc/projects")

THE_PYTHON = "python3.11"

args: argparse.Namespace


def chown_tree(start: Path, username: str, groupname: Optional[str] = None, topdown=True):
    """ change the ownership of the file tree starting at `start` to
        the UNIX user `username` and the UNIX group `groupname`.
        When `topdown` is set (the default) change happens from top to bottom,
        otherwise the other way around.
    """
    if groupname is None:
        groupname = username

    for root, dirs, files in os.walk(start, topdown=topdown):
        for the_dir in dirs:
            dname = Path(root) / the_dir
            shutil.chown(dname, username, groupname)

        for the_file in files:
            fname = Path(root) / the_file
            shutil.chown(fname, username, groupname)

    shutil.chown(start, username, groupname)


def operation(the_op: str) -> str:
    """ ArgumentParser validator for the positional parameter operation.
        Valid operations are in VALID_OPERATIONS.
        We raise a ValueError for anything else.
    """
    if the_op in VALID_OPERATIONS:
        return the_op

    raise ValueError(f"invalid operation {the_op}, valid operatios are {VALID_OPERATIONS}")


def run(cmd: str) -> int:
    """ Run a command, and report
    """
    if (args.debug):
        print(f"*** RUN: {cmd}")
    result = subprocess.run(cmd, capture_output=True, shell=True, timeout=30)

    code = result.returncode
    stdout = result.stdout.decode('utf-8')
    stderr = result.stderr.decode('utf-8')

    if code != 0:
        print(f"*** ERROR: exit code={result.returncode}")

    if stdout and args.debug:
        print(f"*** STDOUT: {stdout}")
    if stderr and args.debug:
        print(f"*** STDERR: {stderr}")

    return code


def check_type(the_type: str) -> bool:
    """ ArgumentParser validator for project types. """
    if the_type in VALID_PROJECT_TYPES:
        return True

    return False


def check_project_exists(project: str) -> bool:
    """ predicate is True if a project file exists in PROJECT_DIR """
    p = PROJECT_DIR / project
    return p.exists() and p.is_file()


def check_username_exists(username: str) -> bool:
    """ predicate is True if user exists in system """
    try:
        pwd.getpwnam(username)
        return True
    except KeyError:
        return False


def check_hostname_valid(hostname: str) -> bool:
    """ predicate is True if hostname ends with .snackbag.net """
    if hostname.endswith(".snackbag.net"):
        return True

    return False


def check_github_valid(github: str) -> bool:
    """ predicate is true if github starts with 'git@github.com:' """
    if github.startswith("git@github.com:"):
        return True

    return False


def get_update_cmd():
    """ Look up an update_cmd from a catalog of choices. """
    choices = {
        "static_site": "/usr/local/bin/pull_force",
        "wsgi_site": "/usr/local/bin/pip_and_pull",
        "discord_bot": "/usr/local/bin/pip_and_pull",
    }

    try:
        return choices[args.type]
    except KeyError:
        raise ValueError(f"Unknown project type: {args.type}")


def get_restart_cmd():
    """ Look up a restart_cmd from a catalog of choices. """
    choices = {
        "static_site": "/usr/local/bin/apache_restart",
        "wsgi_site": "/usr/local/bin/apache_restart",
        "discord_bot": f"/usr/local/bin/restart_service {args.project}",
    }

    try:
        return choices[args.type]
    except KeyError:
        raise ValueError(f"Unknown project type: {args.type}")


def get_log_cmd():
    """ Look up a log_cmd from a catalog of choices. """
    choices = {
        "static_site": "tail -F",
        "wsgi_site": "tail -F",
        "discord_bot": f"/usr/local/bin/logtail {args.project}",
    }

    try:
        return choices[args.type]
    except KeyError:
        raise ValueError(f"Unknown project type: {args.type}")


def get_opts():
    """ Parse the program options using ArgumentParser.
        The collected arguments are left in a global variable args.
    """
    global args

    parser = argparse.ArgumentParser()
    parser.add_argument("operation", type=operation, help="show, create or delete")
    parser.add_argument("project", help="a valid project name, or 'show projects'")

    parser.add_argument("--debug", action="store_true", help="enable debug logging", default=False)

    parser.add_argument("--type", help="one of static_site, wsgi_site or discord_bot")
    parser.add_argument("--hostname", help="hostname ending in .snackbag.net (in create)")
    parser.add_argument("--github", help="git@github.com:...")
    parser.add_argument("--username", help="a unix username to be created (in create)")
    parser.add_argument("--projectdir", help="a subdirectory name in that users home (in create)")

    args = parser.parse_args()


def do_load_project():
    """ Load a project file, except for "show projects", which does not need this. """
    # special case
    if args.operation == "show" and args.project == "projects":
        return

    if not check_project_exists(args.project):
        raise ValueError(f"project {args.project} does not exist")

    project_filename = PROJECT_DIR / args.project
    with open(project_filename, "r") as f:
        project = json.load(f)

    for k, v in project.items():
        setattr(args, k, v)


def validate_or_load_opts():
    """ validate the args for args.operation == "create".
        Call do_load_project() for all other operations.
    """
    global args

    if args.operation == "create":
        if not check_type(args.type):
            raise ValueError(f"invalid project type {args.type}, valid types are {VALID_PROJECT_TYPES}")

        if check_project_exists(args.project):
            raise ValueError(f"project {args.project} already exists")

        if not args.username:
            args.username = args.project
        if check_username_exists(args.username):
            raise ValueError(f"username {args.username} already exists")

        if not args.hostname:
            args.hostname = f"{args.project}.snackbag.net"
        if not check_hostname_valid(args.hostname):
            raise ValueError(f"hostname {args.hostname} does not end in '.snackbag.net'")

        if not args.github:
            raise ValueError(f"github is empty; specify --github <somegithub>")
        if not check_github_valid(args.github):
            raise ValueError(f"github {args.github} is not a valid github url 'git@github.com:...")

        if not args.projectdir:
            args.projectdir = args.username

        args.update_cmd = get_update_cmd()
        args.restart_cmd = get_restart_cmd()
        args.log_cmd = get_log_cmd()
    else:
        do_load_project()

    return


def do_create_user() -> int:
    """ Build a useradd command and run it.
        Also populates the args.home, which is needed a lot later on.
     """
    # user must be created
    comment = f"Project {args.project} owner"
    useradd_cmd = f'/usr/sbin/useradd -m -c "{comment}" {args.username}'
    code = run(useradd_cmd)

    u = pwd.getpwnam(args.username)
    args.home = u.pw_dir

    # must set a+x so that the content can later be accessed by the webserver
    Path(args.home).chmod(0o711)

    return code


def do_delete_user():
    """ Build a userdel command and run it."""
    userdel_cmd = f'/usr/sbin/userdel -r {args.username}'
    code = run(userdel_cmd)

    return code


def do_create_ssh_key():
    """ Build a ssh-keygen command and run it.
        The new key is in {args.home}/.ssh/id_deploykey.
     """

    # Step 1: Create $HOME/.ssh
    homedir = Path(args.home)
    sshdir = homedir / ".ssh"
    sshdir.mkdir(0o700, parents=True, exist_ok=True)

    # Step 2: Create $HOME/.ssh/config
    deploykey = f"{sshdir}/id_deploykey"
    ssh_config_filename = sshdir / "config"
    ssh_config_content = f"""
Host github
    HostName github.com
    User git
    IdentityFile {deploykey}
    IdentitiesOnly yes

Host *
    StrictHostKeyChecking accept-new
"""
    with open(ssh_config_filename, "wt") as ssh_config:
        ssh_config.write(ssh_config_content)

    # Step 3: Create $HOME/.ssh/id_deploykey
    sshkeygen_cmd = f'ssh-keygen -t rsa -b 4096 -N "" -f {deploykey}'
    code = run(sshkeygen_cmd)

    pubkeyfilename = f"{deploykey}.pub"
    with open(pubkeyfilename, "rt") as f:
        # Put the pubkey into args
        args.pubkey = f.read().strip()

    # Step 4: Chown all the files to the user.
    chown_tree(homedir, args.username, args.username)


def do_create_projectfile():
    """ Create a project file in PROJECT_DIR. """
    project_filename = PROJECT_DIR / args.project
    project_desc = {
        "type": args.type,
        "project": args.project,
        "hostname": args.hostname,
        "github": args.github,
        "pubkey": args.pubkey,
        "projectdir": args.projectdir,
        "username": args.username,
        "home": args.home,
        "update_cmd": args.update_cmd,
        "restart_cmd": args.restart_cmd,
        "log_cmd": args.log_cmd,
    }
    project_file_content = json.dumps(project_desc, indent=2, sort_keys=True) + "\n"

    with open(project_filename, "wt") as projectfile:
        projectfile.write(project_file_content)


def do_delete_project_file():
    """ Delete the project file in PROJECT_DIR. """
    project_filename = PROJECT_DIR / args.project
    project_filename.unlink()


def do_git_clone():
    """ Perform a git clone of args.github into $HOME/args.projectdir
        using the identity provided in $HOME/.ssh/config.
    """
    home = Path(args.home)
    repo = home / args.projectdir

    git_clone_cmd = f"git clone {args.github} {repo}"
    code = run(git_clone_cmd)

    # This must all be owned by the user.
    chown_tree(repo, args.username, args.username)


def do_python_setup():
    """ Prepare a git checkout for Python usage. """
    home = Path(args.home)
    repo = home / args.projectdir
    os.chdir(repo)

    # Step 1: create venv
    venv_cmd = f'su -c "{THE_PYTHON} -mvenv venv" {args.username}'
    run(venv_cmd)

    # Step 2: pip_and_pull
    pull_cmd = f'su -c "/usr/local/bin/pip_and_pull" {args.username}'
    run(pull_cmd)


def do_create_apache_config():
    """ Create an apache config in /etc/httpd/conf.sites.d/{args.hostname}.conf. """
    config_filename = f"/etc/httpd/conf.sites.d/{args.hostname}.conf"
    if args.type == "static_site":
        config_content = f"""
Use VHost {args.hostname}

# vim: syntax=apache ts=4 sw=4 sts=4 sr noet
"""
    elif args.type == "wsgi_site":
        config_content = f"""
#   PyApp $host           $title           $appdir                         $unixuser       $unixgroup
Use PyApp {args.hostname} {args.project}   {args.home}/{args.projectdir}   {args.username} {args.username}

# vim: syntax=apache ts=4 sw=4 sts=4 sr noet
"""
    with open(config_filename, "wt") as config_file:
        config_file.write(config_content)


def do_delete_apache_config():
    """ Delete the apache config in /etc/httpd/conf.sites.d/{args.hostname}.conf. """
    config_filename = Path(f"/etc/httpd/conf.sites.d/{args.hostname}.conf")
    config_filename.unlink()


def do_create_site_symlink():
    """ Symlink from /var/www/{args.hostname} to {args.home}/{args.projectdir}. """
    from_path = Path(f"/var/www/{args.hostname}")
    to_path = Path(args.home) / args.projectdir

    from_path.symlink_to(to_path)


def do_delete_site_symlink():
    """ Delete the symlink in /var/www/{args.hostname}. """
    from_path = Path(f"/var/www/{args.hostname}")
    from_path.unlink()


def do_create():
    """ Execute the necessary create steps. """
    if args.type == "static_site":
        do_create_user()
        do_create_ssh_key()
        do_create_projectfile()
        do_git_clone()
        do_create_apache_config()
        do_create_site_symlink()
        run(args.restart_cmd)
        print(f"project {args.projectdir} ({args.type} created")
    elif args.type == "wsgi_site":
        do_create_user()
        do_create_ssh_key()
        do_create_projectfile()
        do_git_clone()
        do_python_setup()
        do_create_apache_config()
        do_create_site_symlink()
        run(args.restart_cmd)
        print(f"project {args.projectdir} ({args.type} created")
    elif args.type == "discord_bot":
        pass  # TODO
    else:
        raise RuntimeError(f"Unknown type {args.type}")


def do_delete():
    """ Execute the necessary delete steps. """
    if args.type == "static_site":
        do_delete_user()
        do_delete_site_symlink()
        do_delete_apache_config()
        do_delete_project_file()
        run(args.restart_cmd)
        print(f"project {args.projectdir} ({args.type}) deleted")
    elif args.type == "wsgi_site":
        do_delete_user()
        do_delete_site_symlink()
        do_delete_apache_config()
        do_delete_project_file()
        run(args.restart_cmd)
        print(f"project {args.projectdir} ({args.type}) deleted")
    elif args.type == "discord_bot":
        # TODO
        pass
    else:
        raise RuntimeError(f"Unknown type {args.type}")


def do_show_all_projects():
    """ Subcommand 'show projects' """
    for p in sorted(list(PROJECT_DIR.glob("*"))):
        print(f"- {p.name}")


def do_show_project():
    """ Subcommand 'show <projectname>' """
    project = PROJECT_DIR / args.project
    if not project.exists():
        raise RuntimeError(f"project {args.project} does not exist")

    with project.open() as f:
        print(f.read())


def do_show():
    """ Subcommand 'show' """
    if args.project == "projects":
        do_show_all_projects()
    else:
        do_show_project()


def main():
    get_opts()
    validate_or_load_opts()

    # operation is one of the things in VALID_OPERATIONS
    if args.operation == "create":
        do_create()
    elif args.operation == "delete":
        do_delete()
    elif args.operation == "show":
        do_show()
    else:
        raise ValueError(f"This can never happen: {args.operation=}")


if __name__ == "__main__":
    main()
