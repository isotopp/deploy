#! /usr/bin/env python3.11

# TODO
# sudo setup fÃ¼r deploy.
#   Sudoable commands: apache_restart, pip_and_pull, pull_force

import argparse
import json
import os
import pwd
import shutil
import socket
import subprocess
import sys
import time
from pathlib import Path
from typing import Optional, Union

VALID_OPERATIONS = ["create", "delete", "show", "restart", "update", "logs"]
VALID_PROJECT_TYPES = ["static_site", "wsgi_site", "discord_bot"]
PROJECT_DIR = Path("/etc/projects")

THE_PYTHON = "python3.11"

args: argparse.Namespace


def chown_tree(start: Path, username: str, groupname: Optional[str] = None, topdown=True):
    """ change the ownership of the file tree starting at `start` to
        the UNIX user `username` and the UNIX group `groupname`.
        When `topdown` is set (the default) change happens from top to bottom,
        otherwise the other way around.
    """
    if groupname is None:
        groupname = username

    for root, dirs, files in os.walk(start, topdown=topdown):
        for the_dir in dirs:
            dname = Path(root) / the_dir
            shutil.chown(dname, username, groupname)

        for the_file in files:
            fname = Path(root) / the_file
            shutil.chown(fname, username, groupname)

    shutil.chown(start, username, groupname)


def to_file(content: str, filename: Union[str, Path, os.PathLike, bytes], *,
            mode: Optional[int] = None,
            owner: Optional[str] = None,
            group: Optional[str] = None) -> None:
    if not isinstance(filename, Path):
        filename = Path(filename)

    with open(filename, "wt") as f:
        f.write(content)

    if mode is not None:
        os.chmod(filename, mode)

    if owner is not None or group is not None:
        shutil.chown(filename, owner, group)


def operation(the_op: str) -> str:
    """ ArgumentParser validator for the positional parameter operation.
        Valid operations are in VALID_OPERATIONS.
        We raise a ValueError for anything else.
    """
    if the_op in VALID_OPERATIONS:
        return the_op

    raise ValueError(f"invalid operation {the_op}, valid operations are {VALID_OPERATIONS}")


def run(cmd: str, *,
        timeout: Optional[int] = None) -> int:
    """ Run a command, and report
    """
    if timeout is None:
        timeout = 30
    if args.debug:
        print(f"*** RUN: {cmd}")

    result = subprocess.run(cmd, capture_output=True, shell=True, timeout=timeout)

    code = result.returncode
    stdout = result.stdout.decode('utf-8')
    stderr = result.stderr.decode('utf-8')

    if code != 0:
        print(f"*** ERROR: exit code={result.returncode}")

    if stdout and args.debug:
        print(f"*** STDOUT: {stdout}")
    if stderr and args.debug:
        print(f"*** STDERR: {stderr}")

    return code


def check_type(the_type: str) -> bool:
    """ ArgumentParser validator for project types. """
    if the_type in VALID_PROJECT_TYPES:
        return True

    return False


def check_project_exists(project: str) -> bool:
    """ predicate is True if a project file exists in PROJECT_DIR """
    p = PROJECT_DIR / project
    return p.exists() and p.is_file()


def check_username_exists(username: str) -> bool:
    """ predicate is True if user exists in system """
    try:
        pwd.getpwnam(username)
        return True
    except KeyError:
        return False


def check_hostname_valid(hostname: str) -> bool:
    """ predicate is True if hostname ends with .snackbag.net """
    if hostname.endswith(".snackbag.net"):
        return True

    return False


def check_github_valid(github: str) -> bool:
    """ predicate is true if github starts with 'git@github.com:' """
    if github.startswith("git@github.com:"):
        return True

    return False


def get_opts():
    """ Parse the program options using ArgumentParser.
        The collected arguments are left in a global variable args.
    """
    global args

    parser = argparse.ArgumentParser()
    parser.add_argument("operation", type=operation, help="one of show, create, delete, restart")
    parser.add_argument("project", help="a valid project name, or 'show projects'")

    parser.add_argument("--debug", action="store_true", help="enable debug logging", default=False)

    parser.add_argument("--type", help="one of static_site, wsgi_site or discord_bot")
    parser.add_argument("--hostname", help="hostname ending in .snackbag.net (in create)")
    parser.add_argument("--github", help="git@github.com:...")
    parser.add_argument("--username", help="a unix username to be created (in create)")
    parser.add_argument("--projectdir", help="a subdirectory name in that users home (in create)")
    parser.add_argument("--timeout", type=int, default=30, help="Extend timeout for running commands (defaul: 30s)")

    args = parser.parse_args()


def load_project_config(project_name: str) -> dict:
    """ Load a project JSON into a dictionary. """
    project_filename = PROJECT_DIR / project_name

    try:
        with open(project_filename, "rt") as project_file:
            config = json.load(project_file)
    except FileNotFoundError:
        raise FileNotFoundError(f"Project file not found: {project_filename}")
    except json.JSONDecodeError as e:
        raise ValueError(f"Error decoding JSON in project file: {e}")

    return config


def do_load_project():
    """ Load a project file, except for "show projects", which does not need this. """
    # special case
    if args.operation == "show" and args.project == "projects":
        return

    if not check_project_exists(args.project):
        raise ValueError(f"project {args.project} does not exist")

    project_config = load_project_config(args.project)

    for k, v in project_config.items():
        setattr(args, k, v)


def validate_or_load_opts():
    """ validate the args for args.operation == "create".
        Call do_load_project() for all other operations.
    """
    global args

    if args.operation == "create":
        if not check_type(args.type):
            raise ValueError(f"invalid project type {args.type}, valid types are {VALID_PROJECT_TYPES}")

        if check_project_exists(args.project):
            raise ValueError(f"project {args.project} already exists")

        if not args.username:
            args.username = args.project
        if check_username_exists(args.username):
            raise ValueError(f"username {args.username} already exists")

        if not args.hostname:
            args.hostname = f"{args.project}.snackbag.net"
        if not check_hostname_valid(args.hostname):
            raise ValueError(f"hostname {args.hostname} does not end in '.snackbag.net'")

        if not args.github:
            raise ValueError(f"github is empty; specify --github <somegithub>")
        if not check_github_valid(args.github):
            raise ValueError(f"github {args.github} is not a valid github url 'git@github.com:...")

        if not args.projectdir:
            args.projectdir = args.username
    else:
        do_load_project()

    return


def do_create_user() -> int:
    """ Build the useradd command and run it.
        Also populates the args.home, which is needed a lot later on.
     """
    # user must be created
    comment = f"Project {args.project} owner"
    code = run(f'/usr/sbin/useradd -m -c "{comment}" {args.username}')

    u = pwd.getpwnam(args.username)
    args.home = u.pw_dir

    # must set a+x so that the content can later be accessed by the webserver
    Path(args.home).chmod(0o711)

    return code


def do_delete_user():
    """ Build the userdel command and run it."""
    code = run(f'/usr/sbin/userdel -r {args.username}')

    return code


def do_create_ssh_key():
    """ Build the ssh-keygen command and run it.
        The new key is in {args.home}/.ssh/id_deploykey.
     """

    # Step 1: Create $HOME/.ssh
    sshdir = Path(args.home) / ".ssh"
    sshdir.mkdir(0o700, parents=True, exist_ok=True)

    # Step 2: Create $HOME/.ssh/config
    deploykey = f"{sshdir}/id_deploykey"
    to_file(f"""
Host github.com
    HostName github.com
    User git
    IdentityFile {deploykey}
    IdentitiesOnly yes
    StrictHostKeyChecking accept-new
""", sshdir / "config", mode=0o644, owner=args.username, group=args.username)

    # Step 3: Create $HOME/.ssh/id_deploykey and save the pubkey
    run(f'ssh-keygen -t rsa -b 4096 -N "" -f {deploykey}')
    args.pubkey = Path(f"{deploykey}.pub").read_text().strip()

    # Step 4: Chown all the files to the user.
    chown_tree(Path(args.home), args.username, args.username)


def do_create_projectfile():
    """ Create a project file in PROJECT_DIR. """
    project_filename = PROJECT_DIR / args.project
    project_desc = {
        "type": args.type,
        "project": args.project,
        "hostname": args.hostname,
        "github": args.github,
        "pubkey": args.pubkey,
        "projectdir": args.projectdir,
        "username": args.username,
        "home": args.home,
    }
    project_file_content = json.dumps(project_desc, indent=2, sort_keys=True) + "\n"
    to_file(project_file_content, project_filename)


def do_delete_project_file():
    """ Delete the project file in PROJECT_DIR. """
    Path(PROJECT_DIR / args.project).unlink(missing_ok=True)


def do_git_clone():
    """ Perform a git clone of args.github into $HOME/args.projectdir
        using the identity provided in $HOME/.ssh/config.
    """
    repo = Path(args.home) / args.projectdir
    run(f"git clone {args.github} {repo}", timeout=args.timeout)

    # This must all be owned by the user.
    chown_tree(repo, args.username, args.username)


def do_python_setup():
    """ Prepare a git checkout for Python usage. """
    home = Path(args.home)
    repo = home / args.projectdir
    os.chdir(repo)

    # Step 1: create venv
    run(f'su -c "{THE_PYTHON} -mvenv venv" {args.username}')

    # Step 2: pip_and_pull
    run(f'su -c "/usr/local/bin/pip_and_pull" {args.username}', timeout=args.timeout)


def do_create_apache_config():
    """ Create an apache config in /etc/httpd/conf.sites.d/{args.hostname}.conf. """
    config_filename = f"/etc/httpd/conf.sites.d/{args.hostname}.conf"
    if args.type == "static_site":
        config_content = f"""
Use VHost {args.hostname}

# vim: syntax=apache ts=4 sw=4 sts=4 sr noet
"""
    elif args.type == "wsgi_site":
        config_content = f"""
#   PyApp $host           $title           $appdir                         $unixuser       $unixgroup
Use PyApp {args.hostname} {args.project}   {args.home}/{args.projectdir}   {args.username} {args.username}

# vim: syntax=apache ts=4 sw=4 sts=4 sr noet
"""
    to_file(config_content, config_filename)


def do_delete_apache_config():
    """ Delete the apache config in /etc/httpd/conf.sites.d/{args.hostname}.conf. """
    Path(f"/etc/httpd/conf.sites.d/{args.hostname}.conf").unlink(missing_ok=True)


def do_create_systemd_service():
    """ Create a systemd service in /etc/systemd/system/{args.project}.service. """
    config_filename = Path(f"/etc/systemd/system/{args.project}.service")
    config_content = f"""
[Unit]
Description={args.project}
After=syslog.target network.target

[Service]
Type=simple
User={args.username}
Group={args.username}
StandardOutput=journal
StandardError=journal
WorkingDirectory={args.home}/{args.projectdir}
ExecStart={args.home}/{args.projectdir}/venv/bin/python3 {args.home}/{args.projectdir}/main.py
Restart=always
EnvironmentFile={args.home}/{args.projectdir}/.env

[Install]
WantedBy=multi-user.target
"""
    to_file(config_content, config_filename)


def do_delete_systemd_service():
    Path(f"/etc/systemd/system/{args.project}.service").unlink(missing_ok=True)
    run(f"systemctl daemon-reload")


def do_create_syslog_config():
    # Step 1: Make sure a log directory and empty log file exist
    rsyslog_target = Path(f"/var/log/services/{args.project}.log")

    rsyslog_target.parent.mkdir(parents=True, exist_ok=True, mode=0o750)
    shutil.chown(rsyslog_target.parent, user="root", group="adm")

    rsyslog_target.touch(mode=0o644, exist_ok=True)
    shutil.chown(rsyslog_target, user="root", group="adm")

    # Step 2: Make sure a rsyslog config exists
    rsyslog_filename = Path(f"/etc/rsyslog.d/{args.project}.conf")
    to_file(f'''
template(name="{args.project}LogFormat" type="string" string="/var/log/services/{args.project}.log")

if $!_SYSTEMD_UNIT == "{args.project}.service" then {{
    action(type="omfile" DynaFile="{args.project}LogFormat")
    stop
}}
''', rsyslog_filename)
    run(f"systemctl restart rsyslog")

    # Step 3: Check if we also need to create a logrotate config
    logrotate_config = Path("/etc/logrotate.d/services")
    if logrotate_config.exists() and logrotate_config.is_file():
        return  # nothing to do

    to_file(f'''/var/log/services/*.log {{
    compress
    missingok
    sharedscripts
    delaycompress
    postrotate
        /usr/bin/systemctl -s HUP kill rsyslog.service >/dev/null 2>&1 || true
    endscript
}}
''', logrotate_config, mode=0o644)


def do_delete_syslog_config():
    Path(f"/etc/rsyslog.d/{args.project}.conf").unlink(missing_ok=True)
    run(f"systemctl restart rsyslog")


def do_systemd_activation():
    run(f"systemctl daemon-reload")
    run(f"systemctl enable {args.project}.service")
    run(f"systemctl start {args.project}.service")


def do_systemd_deactivation():
    run(f"systemctl stop {args.project}.service")
    run(f"systemctl disable {args.project}.service")


def do_create_site_symlink():
    """ Symlink from /var/www/{args.hostname} to {args.home}/{args.projectdir}. """
    from_path = Path(f"/var/www/{args.hostname}")
    to_path = Path(args.home) / args.projectdir

    from_path.symlink_to(to_path)


def do_delete_site_symlink():
    """ Delete the symlink in /var/www/{args.hostname}. """
    Path(f"/var/www/{args.hostname}").unlink(missing_ok=True)


def github_as_https(github: str, subpath: str):
    """ Turn a git@github.com: url into a https url. """

    # git@github.com:vijfhuizen-c0derz/deploy.git
    # https://github.com/vijfhuizen-c0derz/deploy
    if github.startswith("git@github.com:"):
        github = github[len("git@github.com:"):]
    if github.endswith(".git"):
        github = github[:-len(".git")]

    return "https://github.com/" + github + "/" + subpath


def show_deployment_banner():
    print(f"""
We have deployed the site 
{args.hostname}
from 
{args.github}
 
But for the deploy program to be able to update, you need to add the sites' deploy key to their github.

Go to to the sites github, 
{github_as_https(args.github, "settings/keys/new")}
and add
{args.pubkey}
""")


def do_create():
    """ Execute the necessary create steps. """
    if args.type == "static_site":
        do_create_user()
        do_create_ssh_key()
        do_create_projectfile()
        do_git_clone()
        do_create_apache_config()
        do_create_site_symlink()
        do_restart()
        print(f"project {args.project} ({args.type}) created")
        show_deployment_banner()
    elif args.type == "wsgi_site":
        do_create_user()
        do_create_ssh_key()
        do_create_projectfile()
        do_git_clone()
        do_python_setup()
        do_create_apache_config()
        do_create_site_symlink()
        do_restart()
        print(f"project {args.project} ({args.type}) created")
        show_deployment_banner()
    elif args.type == "discord_bot":
        do_create_user()
        do_create_ssh_key()
        do_create_projectfile()
        do_git_clone()
        do_python_setup()
        do_create_systemd_service()
        do_systemd_activation()
        do_create_syslog_config()
        print(f"project {args.project} ({args.type}) created")
        show_deployment_banner()
    else:
        raise RuntimeError(f"Unknown type {args.type}")


def do_delete():
    """ Execute the necessary delete steps. """
    if args.type == "static_site":
        # Clean up the apache
        do_delete_site_symlink()
        do_delete_apache_config()
        do_restart()

        # Now delete the user and the project
        do_delete_user()
        do_delete_project_file()
        print(f"project {args.project} ({args.type}) deleted")
    elif args.type == "wsgi_site":
        # Clean up the apache
        do_delete_site_symlink()
        do_delete_apache_config()
        do_restart()

        # Now delete the user and the project
        do_delete_user()
        do_delete_project_file()
        print(f"project {args.project} ({args.type}) deleted")
    elif args.type == "discord_bot":
        # Clean up the service
        do_systemd_deactivation()
        do_delete_systemd_service()
        do_delete_syslog_config()
        do_restart()

        # Now delete the user and the project
        do_delete_user()
        do_delete_project_file()
        print(f"project {args.project} ({args.type}) deleted")
    else:
        raise RuntimeError(f"Unknown type {args.type}")


def do_show_all_projects():
    """ Subcommand 'show projects' """
    for p in sorted(list(PROJECT_DIR.glob("*"))):
        print(f"- {p.name}")


def do_show_project():
    """ Subcommand 'show <projectname>' """
    project = PROJECT_DIR / args.project
    if not project.exists():
        raise RuntimeError(f"project {args.project} does not exist")

    with project.open() as f:
        config = json.load(f)

    max_key_len = max(len(key) for key in config)

    print(f"*** PROJECT {project}")
    for k, v in sorted(config.items()):
        print(f"- {k:<{max_key_len}}: {v}")


def do_show():
    """ Subcommand 'show' """
    if args.project == "projects":
        do_show_all_projects()
    else:
        do_show_project()


def collect_httpd_hostnames(directory: Path):
    """ Collect all hostnames a directory and build a MDomain statement for Apache. """
    hostnames = []
    for filename in Path(directory).glob("*"):
        with open(filename, 'r') as file:
            try:
                data = json.load(file)
                if 'hostname' in data:
                    hostnames.append(data['hostname'])
                else:
                    print(f"Warning: {filename} contains no hostname.", file=sys.stderr)
            except json.JSONDecodeError:
                print(f"Warning: Failed to parse {filename} as JSON.", file=sys.stderr)

    return hostnames


def do_systemd_restart(service: str):
    run(f"/usr/bin/systemctl stop {service}.service")
    time.sleep(0.5)
    run(f"/usr/bin/systemctl start {service}.service")
    time.sleep(0.5)


def do_httpd_restart():
    """ Restart httpd (twice, because of certificate management) """
    the_hostname = socket.gethostname()
    hostnames = [the_hostname]
    hostnames.append(collect_httpd_hostnames(PROJECT_DIR))
    all_hostnames = " ".join(hostnames)
    to_file(f'''Servername {the_hostname}
MDCertificateAgreement accepted
MDPrivateKeys RSA 4096
MDomain {all_hostnames}
''', Path("/etc/httpd/conf.d/ssldomain.con"))

    for _ in [1, 2]:
        do_systemd_restart("httpd")

    run("/usr/bin/systemctl status httpd.service")


def do_restart():
    if args.type in ["static_site", "wsgi_site"]:
        collect_httpd_hostnames(PROJECT_DIR)
        do_httpd_restart()
    elif args.type == "discord_bot":
        do_systemd_restart(args.project)
    else:
        raise ValueError(f"Unknown type {args.type}")


def do_update():
    """ Update the deployment git repository as needed.
        Local changes will be overwritten.
    """

    # Move into the right directory
    repo = Path(args.home) / args.projectdir
    os.chdir(repo)

    # Do we have a venv?
    venv = Path("./venv")
    requirements = Path("./requirements.txt")

    if venv.exists() and venv.is_dir() and requirements.exists() and requirements.is_file():
        run("venv/bin/python -m pip install -r requirements.txt")

    # Do we have a .git?
    git = Path(".git")
    if git.exists() and git.is_dir():
        run("git reset --hard")
        run("git pull --rebase")


def do_logs():
    if args.type in ["static_site", "wsgi_site"]:
        run(f"tail -F /var/logs/{{access,error}}-{args.hostname}.log")
    elif args.type == "discord_bot":
        pass
    else:
        raise ValueError(f"Unknown type {args.type}")


def main():
    get_opts()
    validate_or_load_opts()

    # operation is one of the things in VALID_OPERATIONS
    if args.operation == "create":
        do_create()
    elif args.operation == "delete":
        do_delete()
    elif args.operation == "show":
        do_show()
    elif args.operation == "restart":
        do_restart()
    elif args.operation == "update":
        do_update()
    elif args.operation == "logs":
        do_logs()
    else:
        raise ValueError(f"This can never happen: {args.operation=}")


if __name__ == "__main__":
    main()
