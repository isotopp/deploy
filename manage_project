#! /usr/bin/env python3

import argparse
import json
import os
import pwd
import shutil
import subprocess
import sys
from pathlib import Path
from typing import Optional

VALID_USERS = ["kris", "joram"]
VALID_OPERATIONS = ["create", "delete", "show"]
VALID_PROJECT_TYPES = ["static_site", "wsgi_site", "discord_bot"]
PROJECT_DIR = Path("projects")

args: argparse.Namespace


def chown_tree(start: Path, username: str, groupname: str, topdown=True):
    """ change the ownership of the file tree starting at `start` to
        the UNIX user `username` and the UNIX group `groupname`.
        When `topdown` is set (the default) change happens from top to bottom,
        otherwise the other way around.
    """
    for root, dirs, files in os.walk(start, topdown=topdown):
        for the_dir in dirs:
            dname = Path(root) / the_dir
            shutil.chown(dname, username, groupname)

        for the_file in files:
            fname = Path(root) / the_file
            shutil.chown(fname, username, groupname)

    shutil.chown(start, username, groupname)


def project_type(the_type: str) -> str:
    """ ArgumentParser validator for project types. """
    if the_type in VALID_PROJECT_TYPES:
        return the_type

    raise ValueError(f"invalid project type {the_type}, valid types are {VALID_PROJECT_TYPES}")


def operation(the_op: str) -> str:
    """ ArgumentParser validator for the positional parameter operation.
        Valid operations are in VALID_OPERATIONS.
        We raise a ValueError for anything else.
    """
    if the_op in VALID_OPERATIONS:
        return the_op

    raise ValueError(f"invalid operation {the_op}, valid operatios are {VALID_OPERATIONS}")


def run(cmd: str) -> int:
    """ Run a command, and report
    """
    print(f"*** RUN: {cmd}")
    result = subprocess.run(cmd, capture_output=True, shell=True, timeout=30)

    code = result.returncode
    stdout = result.stdout.decode('utf-8')
    stderr = result.stderr.decode('utf-8')

    if code != 0:
        print(f"*** ERROR: exit code={result.returncode}")

    if stdout:
        print(f"*** STDOUT: {stdout}")
    if stderr:
        print(f"*** STDERR: {stderr}")

    return code


def create_deploy_description(project: str,
                              hostname: Optional[str] = None,
                              unixuser: Optional[str] = None,
                              projectdir: Optional[str] = None,
                              checkout_cmd: Optional[str] = None,
                              restart_cmd: Optional[str] = None,
                              log_cmd: Optional[str] = None,
                              overwrite: bool = False):
    """ Create a deployment description for a project in `/etc/projects`.
        Will not overwrite an existing project unless `overwrite=True`.

        Optional parameters can be passed, or will be inferred, if left at `None`.

        Default `hostname` is `<project>.snackbag.net.
        Default `unixuser` is `<project>`.
        Default `projectdir` is `$HOME/<project>`.
        Default `checkout_cmd` is `git pull --rebase`.
        Default `restart_cmd` is `sudo apache_restart`.
        Default `log_cmd` is `tail -F`.
    """
    if hostname is None:
        hostname = f"{project}.snackbag.net"

    if unixuser is None:
        unixuser = project

    if projectdir is None:
        u = pwd.getpwnam(unixuser)
        h = u.pw_dir
        projectdir = f"{h}/{project}"

    if checkout_cmd is None:
        checkout_cmd = CHECKOUT_CMD

    if restart_cmd is None:
        restart_cmd = RESTART_CMD

    if log_cmd is None:
        log_cmd = LOG_CMD

    # check the hostname
    if not hostname.endswith("snackbag.net"):
        raise ValueError(f"invalid hostname {hostname}, must end in 'snackbag.net'")

    # to json
    deployment = {
        "hostname": hostname,
        "unixuser": unixuser,
        "projectdir": projectdir,
        "checkout_cmd": checkout_cmd,
        "restart_cmd": restart_cmd,
        "log_cmd": log_cmd,
    }
    deployment_json = json.dumps(deployment, indent=2, sort_keys=True) + "\n"

    # write it
    p = PROJECT_DIR / project
    if p.is_file() and not overwrite:
        print(f"Project {project} already exists.", file=sys.stderr)
        raise FileExistsError(f"can't create: project {project} exists.")

    with p.open("wt") as f:
        f.write(deployment_json)

    return


def check_project_exists(project: str) -> bool:
    p = PROJECT_DIR / project
    return p.exists() and p.is_file()


def check_username_exists(username: str) -> bool:
    try:
        pwd.getpwnam(username)
        return True
    except KeyError:
        return False


def check_hostname_valid(hostname: str) -> bool:
    if hostname.endswith(".snackbag.net"):
        return True

    return False


def check_github_valid(github: str) -> bool:
    if github.startswith("git@github.com:"):
        return True

    return False


def get_update_cmd():
    return "update_cmd"  # TODO


def get_restart_cmd():
    return "restart_cmd"  # TODO


def get_log_cmd():
    return "log_cmd"  # TODO


def get_opts():
    """ Parse the program options using ArgumentParser.
        The collected arguments are left in a global variable args.
    """
    global args

    parser = argparse.ArgumentParser()
    parser.add_argument("operation", type=operation, help="show, create or delete")
    parser.add_argument("project", help="a valid project name, or 'show projects'")

    parser.add_argument("--type", type=project_type, help="one of static_site, wsgi_site or discord_bot")
    parser.add_argument("--hostname", help="hostname ending in .snackbag.net (in create)")
    parser.add_argument("--github", help="git@github.com:...")
    parser.add_argument("--deploykey", help="pathname of a deploykey (private key part)")
    parser.add_argument("--username", help="a unix username to be created (in create)")
    parser.add_argument("--projectdir", help="a subdirectory name in that users home (in create)")

    args = parser.parse_args()


def validate_opts():
    global args

    if check_project_exists(args.project):
        raise ValueError(f"project {args.project} already exists")

    if not args.username:
        args.username = args.project
    if check_username_exists(args.username):
        raise ValueError(f"username {args.username} already exists")

    if not args.hostname:
        args.hostname = f"{args.project}.snackbag.net"
    if not check_hostname_valid(args.hostname):
        raise ValueError(f"hostname {args.hostname} does not end in '.snackbag.net'")

    if not args.github:
        raise ValueError(f"github is empty; specify --github <somegithub>")
    if not check_github_valid(args.github):
        raise ValueError(f"github {args.github} is not a valid github url 'git@github.com:...")

    if not args.projectdir:
        args.projectdir = args.username

    args.update_cmd = get_update_cmd()
    args.restart_cnd = get_restart_cmd()
    args.log_cmd = get_log_cmd()

    return


def do_create_user() -> int:
    # user must be created
    comment = f"Project {args.project} owner"
    useradd_cmd = f"/usr/sbin/useradd -m -c {comment} {args.username}"
    code = run(useradd_cmd)

    u = pwd.getpwnam(args.username)
    args.userid = u.pw_uid

    return code


def do_create_ssh_key():
    u = pwd.getpwnam(args.username)
    homedir = Path(u.pw_dir)

    if not args.deploykey:
        sshdir = homedir / ".ssh"
        sshdir.mkdir(0o700, parents=True, exist_ok=True)
        args.deploykey = f"{sshdir}/id_deploykey"

    sshkeygen_cmd = "ssh-keygen -t rsa -b 4096 -N "" -f {args.deploykey}"
    code = run(sshkeygen_cmd)

    pubkeyfilename = f"{args.deploykey}.pub"
    with open(pubkeyfilename, "rt") as f:
        args.pubkey = f.read()


def do_create_projectfile():
    projectfile = PROJECT_DIR / args.project
    projectfile_content = {
        "type": args.type,
        "project": args.project,
        "hostname": args.hostname,
        "github": args.github,
        "deploykey": args.deploykey,
        "pubkey": args.pubkey,
        "projectdir": args.projectdir,
        "username": args.username,
        "userid": args.userid,
        "update_cmd": args.update_cmd,
        "restart_cmd": args.restart_cmd,
        "log_cmd": args.log_cmd,
    }

    with open(projectfile, "w") as projectfile:
        projectfile.write(projectfile_content)


def do_create():
    do_create_user()
    do_create_ssh_key()
    do_create_projectfile()


def main():
    get_opts()
    validate_opts()

    # operation is one of the things in VALID_OPERATIONS
    if args.operation == "create":
        do_create()
    elif args.operation == "delete":
        print(f"delete: {args}")
    elif args.operation == "show":
        print(f"show: {args}")
    else:
        raise ValueError(f"This can never happen: {args.operation=}")


if __name__ == "__main__":
    main()
