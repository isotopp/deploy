#! /usr/bin/env python3
import argparse
import json
import os
import subprocess
from pathlib import Path

VALID_USERS = ["kris", "joram"]
VALID_OPERATIONS = ["code", "deploy", "logs", "show"]
PROJECT_DIR = Path("/etc/projects")

args: argparse.Namespace


def operation(the_op: str) -> str:
    """ ArgumentParser validator for the positional parameter operation.
        Valid operations are in VALID_OPERATIONS.
        We raise a ValueError for anything else.
    """
    if the_op in VALID_OPERATIONS:
        return the_op

    raise ValueError


def get_opts():
    """ Parse the program options using ArgumentParser.
        The collected arguments are left in a global variable args.
    """
    global args

    parser = argparse.ArgumentParser()
    parser.add_argument("--debug", action="store_true", help="enable debug logging", default=False)
    parser.add_argument("operation", type=operation, help="code or deploy, logs, show")
    parser.add_argument("project", help="a valid project name")

    args = parser.parse_args()


def run(cmd: str) -> int:
    """ Run a command, and report
    """
    if args.debug:
        print(f"*** RUN: {cmd}")
    result = subprocess.run(cmd, capture_output=True, shell=True, timeout=30)

    code = result.returncode
    stdout = result.stdout.decode('utf-8')
    stderr = result.stderr.decode('utf-8')

    if code != 0:
        print(f"*** ERROR: exit code={result.returncode}")

    if stdout and args.debug:
        print(f"*** STDOUT: {stdout}")
    if stderr and args.debug:
        print(f"*** STDERR: {stderr}")

    return code


def log_project(project: str):
    p = PROJECT_DIR / project
    if not p.is_file():
        raise ValueError(f"cannot deploy to project {project}, no project file found.")

    config = load_deploy_description(project)
    workdir = Path(config["home"]) / config["projectdir"]
    os.chdir(workdir)

    if config['log_cmd'] == "tail -F":
        log_cmd = config['log_cmd']
        log_cmd += f" /var/log/httpd/access-{config['hostname']}.log "
        log_cmd += f" /var/log/httpd/error-{config['hostname']}.log "
    else:
        log_cmd = config['log_cmd']
    print(f"Running {log_cmd}")
    subprocess.run(log_cmd, shell=True)


def deploy_code(project: str):
    p = PROJECT_DIR / project
    if not p.is_file():
        raise ValueError(f"cannot deploy to project {project}, no project file found.")

    config = load_deploy_description(project)
    target = Path(config["home"]) / config["projectdir"]
    os.chdir(target)
    cwd = os.getcwd()

    deploy_cmd = f"sudo -u {config['username']} {config['update_cmd']}"
    print(f"In '{cwd}', run command: '{deploy_cmd}'")

    code = run(deploy_cmd)
    if code != 0:
        print("*** DEPLOYMENT ABORTED ***")
        print("*** NO SERVICE RESTART ***")
        return

    restart_cmd = config['restart_cmd']
    print(f"Running restart_cmd {restart_cmd}")

    run(restart_cmd)


def load_deploy_description(project: str) -> dict:
    p = PROJECT_DIR / project
    text = p.read_text()
    data = json.loads(text)

    return data


def show_all_deployment_descriptions():
    p = PROJECT_DIR.glob("*")
    names = [n.name for n in p]

    for name in sorted(names):
        print(f"- {name}")


def show_deployment_description(project: str):
    if project == "project" or project == "projects":
        show_all_deployment_descriptions()
        return

    config = load_deploy_description(project)
    max_key_len = max(len(key) for key in config)

    print(f"*** PROJECT {project}")
    for k, v in sorted(config.items()):
        print(f"- {k:<{max_key_len}}: {v}")


def main():
    # Check valid user, and grab the call options
    get_opts()

    # operation is one of the things in VALID_OPERATIONS
    if args.operation == "code" or args.operation == "deploy":
        deploy_code(project=args.project)
    elif args.operation == "logs":
        log_project(project=args.project)
    elif args.operation == "show":
        show_deployment_description(project=args.project)
    else:
        raise ValueError(f"This can never happen: {args.operation=}")


if __name__ == "__main__":
    main()
